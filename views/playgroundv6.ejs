<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
        }
        .editor {
            background-color: pink;
            margin: 0;
            list-style: lines;
        }

        .editor-line {
            padding: 3px 6px;
            border-bottom: 1px solid red;
        }

        .editor-line:focus {
            background-color: white;
            outline: 1px solid purple;
            border-bottom: none 
        }

        .editor-line:last-child {
            border-bottom: none;
        }

        @counter-style lines {
            system: numeric;
            symbols: "0" "1" "2" "3" "4" "5" "6" "7" "8" "9";
            suffix: ": ";
        }
    </style>
</head>
<body>
    
    <ul class="editor" id="editor" contenteditable="true">
        <li data-type="line">AAAAAAAAAA</li>
        <li data-type="line">AAAAAAAAAA</li>
        <li data-type="line">AAAAAAAAAA</li>
        <li data-type="line">AAAAAAAAAA</li>
        <li data-type="line">AAAAAAAAAA</li>
        <li data-type="line">AAAAAAAAAA</li>
        <li data-type="line">AAAAAAAAAA</li>
        <li data-type="line">AAAAAAAAAA</li>
    </ul>


    <script>

        class Line {
            constructor(text){
                

            }

            get node(){
                return this.eListItem
            }

            
        }

        class Type {
            constructor(editor){
                this.editor = editor;

                this.editor.addEventListener("keydown", this.onKeyDown)
                this.editor.addEventListener("keyup", this.onKeyUp)
                this.editor.addEventListener("paste", this.onPaste)

                this.selection = window.getSelection();
                
            }

            get range(){
                return this.selection.getRangeAt(0)
            }

            get anchorNode(){
                return this.selection.anchorNode
            }

            get position(){
                return this.range.startOffset;
            }

            get endPosition(){
                return this.range.endOffset;
            }

            get wholeText(){
                return this.anchorNode.wholeText
            }

            get textContent(){
                return this.anchorNode.textContent
            }

            set textContent(plainText){
                this.anchorNode.textContent = plainText
            }


            set innerText(value) {
                this.anchorNode.innerText = value
            }

            get innerText() {
                return this.anchorNode.innerText
            }


            removeChildren(element){
                while (element.firstChild) {
                    element.removeChild(element.firstChild);
                }

            }

            insertText(plainText){
                
                const lines = plainText.split(/\n/);
                const firstLine = lines.shift();

                const leftOfCursor = this.textContent.substring(0, this.position);
                const rightOfCursor = this.textContent.substring(this.endPosition);
                let newCaretPosition;

                if(lines.length === 0){
                    newCaretPosition = this.position + firstLine.length;
                    // Remove text right of the cursor from current line and insert first line
                    this.textContent = `${leftOfCursor}${firstLine}${rightOfCursor}`;
                
                } else {
                    newCaretPosition = lines[lines.length - 1].length;

                    lines[lines.length - 1] += rightOfCursor;

                    // Remove text right of the cursor from current line and insert first line
                    this.textContent = `${leftOfCursor}${firstLine}`;

                    lines.forEach((line) => {
                        this.insertNewLine(line)
                    })
                }

                this.selection.setPosition(this.anchorNode, newCaretPosition)
               
            }

            

            onEnter(e) {
                e.preventDefault();
                const selectedNodes = this.getSelectedNodes();

                if (this.selection.isCollapsed) {
                    this.splitLine(e)

                } else {
                    if(selectedNodes.length > 0){
                        // Replace the range with an empty string
                        this.replaceCrossNodeRange("", selectedNodes)

                        // Insert a line
                        this.splitLine(e)
                    } else {
                        // Replace range with an empty string
                        this.insertText("\n")
                    }
                }

            }

            insertNewLine(plainText){
                const newCaretPosition = plainText.length;

                const newLineTextNode = document.createTextNode(plainText)
                const newLine = document.createElement("li")
                newLine.setAttribute("data-type", "line")
                newLine.appendChild(newLineTextNode)

                this.line.after(newLine)

                // Move cursor to end of newly inserted text
                this.selection.setPosition(newLineTextNode, 0)
            }

            splitLine(e){
                // Get the Plain Text of the anchorNode before and after the cursor
                const leftOfCursor = this.textContent.substring(0, this.position);
                const rightOfCursor = this.textContent.substring(this.endPosition);

                // Update the textContent of the anchorNode
                this.textContent = leftOfCursor;
                
                this.insertNewLine(rightOfCursor);
                
            }

            replaceCrossNodeRange(plainText, selectedNodes){
                const leftOfCursor = selectedNodes[0].textContent.substring(0, this.position);
                const rightOfCursor = selectedNodes[selectedNodes.length - 1].textContent.substring(this.endPosition);

                // Concatinate the left text, new text and right text
                const newTextNode = document.createTextNode(`${leftOfCursor}${plainText}${rightOfCursor}`)
                const newCaretPosition = this.position + plainText.length;

                // Delete selected nodes
                this.deleteSelectedNodes();

                // Update the textContent of the anchorNode
                this.textContent = newTextNode.textContent;

                this.selection.setPosition(this.anchorNode, newCaretPosition);

            }

            deleteSelectedNodes({keepAnchor = true} = {}){
                const containerNode = this.range.commonAncestorContainer;
                const nodesToDelete = []

                const filterMethod = (node) => {
                    return (keepAnchor) ?
                        (this.selection.containsNode(node, true) && !node.contains(this.anchorNode)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
                    :
                        (this.selection.containsNode(node, true)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
                };

                const walker = document.createTreeWalker(containerNode, NodeFilter.SHOW_ALL, filterMethod);

                while(walker.nextNode()) {
                    nodesToDelete.push(walker.currentNode)
                }

                nodesToDelete.forEach(node => node.remove())

            }

            getSelectedNodes(){
                const containerNode = this.range.commonAncestorContainer;
                const filterMethod = (node) => {
                    return (node.nodeType === Node.TEXT_NODE && node.nodeValue.trim() !== "" && this.selection.containsNode(node, true)) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
                };
                const walker = document.createTreeWalker(containerNode, NodeFilter.TEXT_NODE, filterMethod);
                const nodes = []

                while(walker.nextNode()) {
                    nodes.push(walker.currentNode)
                }

                return nodes;
            }

            cleanup(){
                // use normalize()
            }

            get line(){
                let line = null;
                if(this.anchorNode.getAttribute && this.anchorNode.getAttribute("data-type") === "line"){
                    line = this.anchorNode
                } else {
                    line = this.anchorNode.parentNode.closest("[data-type='line']")
                }

                return line
            }

            onDelete(e){
                console.log("onDelete")
            }

            onPaste = (e) => {
                e.preventDefault();

                const plainText = e.clipboardData.getData("text/plain");
                const selectedNodes = this.getSelectedNodes();


                if(selectedNodes.length > 0){
                    // Range spans one or more 
                    this.replaceCrossNodeRange(plainText, selectedNodes)
                } else {
                    // No Range or Range that starts and ends in the same node
                    this.insertText(plainText)
                }

            }

            onKeyDown = (e) => {
                const text = e.target.innerText;
                const pressedKey = e.key;
                const ctrlPressed = e.ctrlKey;
                const shiftPressed = e.shiftKey;
                const log = true;

                if(log){
                    console.groupCollapsed(`KEY DOWN: ${pressedKey}`)
                    console.log(e)
                    console.log("text:", text)
                    console.log("pressedKey:", pressedKey)
                    console.log("ctrlPressed:", ctrlPressed)
                    console.log("shiftPressed:", shiftPressed)
                    console.groupEnd()
                }

                switch(pressedKey){
                    case "Enter":
                        this.onEnter(e);
                        break;
                    case "Backspace":
                        this.onDelete(e)
                        break;
                }
            }

            onKeyUp = (e) => {
                const text = e.target.innerText;
                const pressedKey = e.key;
                const ctrlPressed = e.ctrlKey;
                const shiftPressed = e.shiftKey;
                const log = false;

                if(log){
                    console.groupCollapsed(`KEY UP: ${pressedKey}`)
                    console.log(e)
                    console.log("text:", text)
                    console.log("pressedKey:", pressedKey)
                    console.log("ctrlPressed:", ctrlPressed)
                    console.log("shiftPressed:", shiftPressed)
                    console.groupEnd()  
                }
            }

        }

        const editor = document.getElementById("editor");

        const type = new Type(editor)

    </script>

</body>
</html>